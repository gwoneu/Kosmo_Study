- 알고리즘

재귀(Recursion), 탐색(Searching), 정렬(Sorting)

탐색 알고리즘 : 데이터 구조에서 특정 값을 찾는 방법

1. 선형 탐색(Linear Search)
가장 간단한 형태의 알고리즘이며, 리스트의 처음부터 끝까지 원하는 요소를 찾을 때까지 하나하나 확인한다.
시간복잡도가 최선의 경우0(1), 최악의 경우0(n) 이다. 여기서 n은 리스트의 길이를 나타낸다.
정렬에 대한 의미가 없다.

2. 이진 탐색(Binary Search)
이진 탐색은 정렬된 배열에서 특정 값을 찾는데 사용되는 효율적인 알고리즘
중간 값과 찾으려는 값을 비교해서 검색 범위를 절반으로 줄여나간다.
매 단계 검사해야할 요소가 절반으로 줄어들기 때문에 시간 복잡도는 O(log N)이다.

- 알고리즘 복잡도 : 알고리즘이 얼마나 많은 리소스를 사용하는지 측정하는 방법
+ 시간 복잡도 : 알고리즘이 문제를 해결하는데 얼마나 많은 시간이 필요한지를 측정
입력 크기에 따른 연산 횟수로 표현하며 이 연산횟수가 증가하는 속도를 나타내는 것이 중요하다.

+ 공간 복잡도 : 알고리즘이 문제를 해결하는데 얼마나 많은 메모리가 필요한지를 측정
입력 데이터 외에 추가적으로 필요한 공간

Big O notation은 시간 및 공간 복잡도를 표현하기 위한 수학 표기법
O()은 최악의 경우(worst case scenario)에서 알고리즘의 성능을 의미하며 입력 크기 n에 대한 함수의 상한선(upper bound)를 제공한다.

1. O(1) : 상수 시간(constant time) -> 입력 크기와 무관하게 항상 동일한 시간이 걸린다.
2. O(n) : 선형 시간(linear time) -> 입력 크기에 비례해서 처리 시간이 증가한다.
3. O(n^2) : 제곱 시간(quadratic time) -> 입력 크기의 제곱에 비례해서 처리 시간이 증가한다.
4. O(log n) : 로그 시간(logarithmic time) -> 로그 함수와 같이 초기에 빠르게 감소하다가 점차 감소 속도가 줄어든다.
5. O(n log n) : 선형 로그 시간(linear logarithmic time) -> 선형 시간과 로그 시간의 곱만큼 처리 시간이 증가한다.

1 -> 4 -> 2 -> 5 -> 3

- 정렬
lst = [11,3,24,9,40,33,7,2,8,30]

1) 선택정렬(Selection Sort)
가장 간단하지만 효율성이 떨어지는 정렬 알고리즘 중 하나다.
기본 아이디어는 매 순환(linear Search)에서 가장 작은(큰) 요소를 찾아 위치를 이동하여 정렬하는 것
리스트에서 최소값을 찾는다. -> 그 값을 첫번째 값과 교환한다. -> 남은 리스트 중 가장 작은 값을 두번째 값과 교환한다.
-> 이 과정을 전체 리스트가 정렬될 때까지 반복한다.

[29, 10, 14, 37, 13]
[10, 29, 14, 37, 13]
[10, 13, 14, 37, 29]
[10, 13, 14, 37, 29]
[10, 13, 14, 29, 37]
=> n*n-1

시간복잡도 : O(n^2)

2) 삽입 정렬(Insertion Sort)
1. 리스트의 두 번째 요소부터 시작하여 현재 키를 그 이전의 모든 요소와 비교한다.
2. 키가 이전 요소보다 작으면, 이저 요소를 한 위치 오른쪽으로 이동시킨다.
3. 키가 이전 요소보다 큰 위치를 찾을 때까지 혹은 모든 이전 요소를 확인 할때까지 반복한다.
4. 원하는 위치에 키 값을 삽입한다.
5. 해당 과정을 모든 요소에 대해 반복하여 정렬한다.

[29, 10, 14, 37, 13]
[, 29, 14, 37, 13] -10
[10, 29, 14, 37, 13]
[10, , 29, 37, 13] -14
[10, 14, 29, 37, 13]
[10, 14, 29, , 37] -13
[10, 14, , 29, 37] -13
[10, , 14, 29, 37] -13
[10, 13, 14, 29, 37]

과제
1. 이진 탐색
정렬된 2D 행렬에서 특정 값을 찾는 알고리즘을 구현하기 -> True, False
matrix = [
    [1, 4, 7, 11, 15],
    [2, 5, 8, 12, 19],
    [3, 6, 9, 16, 22],
    [10, 13, 14, 17, 24],
    [18, 21, 23, 26, 30]
]

2. 주어진 리스트에서 가장 많이 등장하는 값을 찾아 반환하기. -> 5
arr = [1, 3, 2, 2, 8, 3, 5, 5, 5]