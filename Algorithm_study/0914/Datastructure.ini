자료구조 (Data Structure), 알고리즘(Algorithm)
자료구조(메모리), 알고리즘(속도)
어떻게 하면 최저의 비용으로 최고의 성과를 낼지
메모리가 줄면, 속도도 준다. (비용 감소)
메모리가 증가하면, 속도도 빨라진다. (비용 증가)

- 자료 구조 : 데이터를 효율적으로 저장, 조직화, 관리하기 위한 방법

1. 배열(Array)
2. 스택(Stack)과 큐(Queue)
3. 연결리스트(Linked List)
4. 트리(Tree)
5. 그래프(Graph)
6. 해시 테이블(Hash Table)

- 배열 : 동일한 유형(타입)의 요소들의 데이터들이 연속적인 메모리 공간 저장되는 자료구조.
1) 연속적인 메모리 공간 : 배열의 데이터들이 메모리에서 연속적으로 할당되기 때문에, 인덱스로 통해 데이터 접근할 수 있다.
2) 고정된 크기 : 배열은 생성할 떄, 크기가 결정되며 일단 생성된 배열의 크기는 변경할 수 없다.
3) 인덱스 기반 접근 : 시작 요소가 0번째로 시작된다. 인덱스 기반 접근이기 때문에 빠른 읽기와 쓰기가 가능하다.
4) 동일한 유형의 데이터 저장

<장점>
1. 속도가 빠르다.
2. 연속적인 할당으로 캐시 지역성(Cache Locality) 성능 향상 - 흩어진게 아닌 모여있어서
3. 간단하고 직관적

<단점>
1. 크기 제약
2. 삭제와 삽입 불가능
3. 메모리 낭비

- 스택(Staak)
후입선출(LIFO, Last-in-First-Out) : 가장 나중에 들어간게 먼저 나온다.
마지막에 삽입된 요소가 가장 먼저 제거된다.
push : 스택의 맨 위에 요소를 추가한다.
pop : 스택의 맨 위에 요소를 제거하고 반환한다.
peek/top : 스택의 맨 뒤에 요소를 조회한다.
<-- 바구니 예시 -->

함수 호출과 복귀 : 함수 호출 시 호출된 함수의 정보(지역변수, 매개변수 등)을 스택에 저장하고, 함수가 완료되면 역순으로 복귀한다.
괄호 검사 : 괄호 짝이 맞는지 확인하기 위해 여는 괄호가 나오면 stack에 push를 하고 (닫는 괄호가 나올 때까지), 짝을 이루면 pop을 한다.
뒤집기 : 문자열, 배열 스택에 넣고 순서대로 꺼내면 바로 역순이 된다.

- 큐(Queue)
선입선출(FIFO, First-In-First-Out)
가장 처음 삽입된 요소가 가장 먼저 제거된다.
Enqueue : 큐의 뒤쪽(rear)에 요소를 추가한다.
Dequeue : 큐의 앞쪽(front)의 요소를 제거하고 반환한다.
Front, Peek : 큐의 앞쪽에서 요소를 조회한다.

작업 대기열(Task Queue) : 여러 작업들이 들어올 때 순서대로 처리하기 위해 큐를 사용한다.(선입선출)
너비 우선 탐색(BFS, Breadth-First-Search) : 그래프나 트리 탐색 시 BFS에서 인접한 정점들을 방문 순서대로 처리한다.

- 연결 리스트(Linked List) : 노드(Node)들이 포인터로 서로 연결되어 있는 자료구조
노드 : 데이터와 다음 노드를 가르키는 포인터(주소)

1. 단일 연결 리스트(Singly Linked List)
각 노드는 데이터 필드와 다음 노드를 가르키는 포인터 필드로 구성된다.
마지막 노드의 포인터 필드 값을 보토 NULL이며, 이는 리스트의 끝을 나타낸다.
<장점>
삽입, 삭제가 효율적이고 간단하다. 앞, 뒤 노드만 수정하면 되기 떄문!
동적 크기 조정이 가능하다.

<단점>
특정 위치에 직접 접근하기 위해서는 처음부터 순차적으로 탐색해야 한다.

2. 이중 연결 리스트(Doubly Linked List)
각 노드는 데이터 필드와 이전 노드를 가르키는 포인터 필드, 다음 노드를 가르키는 포인터 필드로 구성된다.
첫 번째 요소, 마지막 요소에 대한 접근이 가능하다.

<장점>
양방향으로 탐색이 가능하여 특정 위치에서의 삽입과 삭제가 단일 연결리스트보다 효율적이다.
역방향 탐색 및 반대방향에서의 삽입/삭제가 가능하다.

<단점>
이전(prev) 포인터를 유지해야하므로 추가 메모리 공간을 사용한다.

1. 삽입(insertion)
2. 삭제(Deletion)

# 단일 연결 리스트
class Node {
    int data;
    Node next;
}

# 이중 연결 리스트
class Node {
    int data;
    Node prev;
    Node next;
}